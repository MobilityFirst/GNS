//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../../gig_ios/src/edu/umass/cs/nio/AbstractNIOSSL.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "edu/umass/cs/nio/AbstractNIOSSL.h"
#include "edu/umass/cs/nio/NIOTransport.h"
#include "edu/umass/cs/nio/nioutils/NIOInstrumenter.h"
#include "edu/umass/cs/utils/Util.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalAccessException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NoSuchFieldException.h"
#include "java/lang/Runnable.h"
#include "java/lang/SecurityException.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/lang/annotation/Annotation.h"
#include "java/lang/reflect/Field.h"
#include "java/nio/Buffer.h"
#include "java/nio/BufferOverflowException.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/channels/SelectableChannel.h"
#include "java/nio/channels/SelectionKey.h"
#include "java/util/concurrent/Executor.h"
#include "java/util/logging/Level.h"
#include "java/util/logging/Logger.h"
#include "javax/net/ssl/SSLEngine.h"
#include "javax/net/ssl/SSLEngineResult.h"
#include "javax/net/ssl/SSLException.h"
#include "javax/net/ssl/SSLSession.h"
#include "sun/misc/Cleaner.h"

@interface EduUmassCsNioAbstractNIOSSL ()

- (JavaNioByteBuffer *)getBiggerBufferWithJavaNioByteBuffer:(JavaNioByteBuffer *)buf1
                                      withJavaNioByteBuffer:(JavaNioByteBuffer *)buf2;

+ (JavaNioByteBuffer *)getBiggerBufferWithJavaNioByteBuffer:(JavaNioByteBuffer *)buf
                                                    withInt:(jint)size;

- (jboolean)step;

- (jboolean)wrap;

- (void)drainOutbound;

- (void)pushOutbound;

- (void)pullInbound;

- (jboolean)unwrap;

+ (void)cleanWithJavaNioByteBuffer:(JavaNioByteBuffer *)bbuf;

@end

inline jint EduUmassCsNioAbstractNIOSSL_get_DEFAULT_BUFFER_SIZE();
#define EduUmassCsNioAbstractNIOSSL_DEFAULT_BUFFER_SIZE 262144
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsNioAbstractNIOSSL, DEFAULT_BUFFER_SIZE, jint)

inline jint EduUmassCsNioAbstractNIOSSL_get_MAX_FACTOR();
#define EduUmassCsNioAbstractNIOSSL_MAX_FACTOR 1
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsNioAbstractNIOSSL, MAX_FACTOR, jint)

inline jint EduUmassCsNioAbstractNIOSSL_get_MAX_BUFFER_SIZE();
#define EduUmassCsNioAbstractNIOSSL_MAX_BUFFER_SIZE 262144
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsNioAbstractNIOSSL, MAX_BUFFER_SIZE, jint)

inline jint EduUmassCsNioAbstractNIOSSL_get_MAX_DST_BUFFER_SIZE();
#define EduUmassCsNioAbstractNIOSSL_MAX_DST_BUFFER_SIZE 262144
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsNioAbstractNIOSSL, MAX_DST_BUFFER_SIZE, jint)

inline JavaUtilLoggingLogger *EduUmassCsNioAbstractNIOSSL_get_log();
static JavaUtilLoggingLogger *EduUmassCsNioAbstractNIOSSL_log;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EduUmassCsNioAbstractNIOSSL, log, JavaUtilLoggingLogger *)

__attribute__((unused)) static JavaNioByteBuffer *EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withJavaNioByteBuffer_(EduUmassCsNioAbstractNIOSSL *self, JavaNioByteBuffer *buf1, JavaNioByteBuffer *buf2);

__attribute__((unused)) static JavaNioByteBuffer *EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withInt_(JavaNioByteBuffer *buf, jint size);

__attribute__((unused)) static jboolean EduUmassCsNioAbstractNIOSSL_step(EduUmassCsNioAbstractNIOSSL *self);

__attribute__((unused)) static jboolean EduUmassCsNioAbstractNIOSSL_wrap(EduUmassCsNioAbstractNIOSSL *self);

__attribute__((unused)) static void EduUmassCsNioAbstractNIOSSL_drainOutbound(EduUmassCsNioAbstractNIOSSL *self);

__attribute__((unused)) static void EduUmassCsNioAbstractNIOSSL_pushOutbound(EduUmassCsNioAbstractNIOSSL *self);

__attribute__((unused)) static void EduUmassCsNioAbstractNIOSSL_pullInbound(EduUmassCsNioAbstractNIOSSL *self);

__attribute__((unused)) static jboolean EduUmassCsNioAbstractNIOSSL_unwrap(EduUmassCsNioAbstractNIOSSL *self);

__attribute__((unused)) static void EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(JavaNioByteBuffer *bbuf);

__attribute__((unused)) static IOSObjectArray *EduUmassCsNioAbstractNIOSSL__Annotations$0();

@interface EduUmassCsNioAbstractNIOSSL_1 : NSObject < JavaLangRunnable > {
 @public
  EduUmassCsNioAbstractNIOSSL *this$0_;
  id<JavaLangRunnable> val$sslTask_;
}

- (instancetype)initWithEduUmassCsNioAbstractNIOSSL:(EduUmassCsNioAbstractNIOSSL *)outer$
                               withJavaLangRunnable:(id<JavaLangRunnable>)capture$0;

- (void)run;

@end

J2OBJC_EMPTY_STATIC_INIT(EduUmassCsNioAbstractNIOSSL_1)

__attribute__((unused)) static void EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(EduUmassCsNioAbstractNIOSSL_1 *self, EduUmassCsNioAbstractNIOSSL *outer$, id<JavaLangRunnable> capture$0);

__attribute__((unused)) static EduUmassCsNioAbstractNIOSSL_1 *new_EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(EduUmassCsNioAbstractNIOSSL *outer$, id<JavaLangRunnable> capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduUmassCsNioAbstractNIOSSL_1 *create_EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(EduUmassCsNioAbstractNIOSSL *outer$, id<JavaLangRunnable> capture$0);

@interface EduUmassCsNioAbstractNIOSSL_2 : NSObject < JavaLangRunnable > {
 @public
  EduUmassCsNioAbstractNIOSSL *this$0_;
}

- (instancetype)initWithEduUmassCsNioAbstractNIOSSL:(EduUmassCsNioAbstractNIOSSL *)outer$;

- (void)run;

@end

J2OBJC_EMPTY_STATIC_INIT(EduUmassCsNioAbstractNIOSSL_2)

__attribute__((unused)) static void EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(EduUmassCsNioAbstractNIOSSL_2 *self, EduUmassCsNioAbstractNIOSSL *outer$);

__attribute__((unused)) static EduUmassCsNioAbstractNIOSSL_2 *new_EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(EduUmassCsNioAbstractNIOSSL *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static EduUmassCsNioAbstractNIOSSL_2 *create_EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(EduUmassCsNioAbstractNIOSSL *outer$);

J2OBJC_INITIALIZED_DEFN(EduUmassCsNioAbstractNIOSSL)

@implementation EduUmassCsNioAbstractNIOSSL

- (instancetype)initWithJavaNioChannelsSelectionKey:(JavaNioChannelsSelectionKey *)key
                           withJavaxNetSslSSLEngine:(JavaxNetSslSSLEngine *)engine
                     withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)taskWorkers
                                       withNSString:(NSString *)myID {
  EduUmassCsNioAbstractNIOSSL_initWithJavaNioChannelsSelectionKey_withJavaxNetSslSSLEngine_withJavaUtilConcurrentExecutor_withNSString_(self, key, engine, taskWorkers, myID);
  return self;
}

- (void)onInboundDataWithJavaNioByteBuffer:(JavaNioByteBuffer *)decrypted {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)onOutboundDataWithJavaNioByteBuffer:(JavaNioByteBuffer *)encrypted {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)onHandshakeFailureWithJavaLangException:(JavaLangException *)cause {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)onHandshakeSuccess {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)onClosed {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)nioSendWithJavaNioByteBuffer:(JavaNioByteBuffer *)unencrypted {
  @synchronized(self) {
    @try {
      EduUmassCsUtilsUtil_putWithJavaNioByteBuffer_withJavaNioByteBuffer_(wrapSrc_, unencrypted);
    }
    @catch (JavaNioBufferOverflowException *boe) {
      JreStrongAssign(&wrapSrc_, EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withJavaNioByteBuffer_(self, wrapSrc_, unencrypted));
      [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, INFO) withNSString:@"{0} increased wrapSrc buffer size to {1}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self, JavaLangInteger_valueOfWithInt_([((JavaNioByteBuffer *) nil_chk(wrapSrc_)) capacity]) } count:2 type:NSObject_class_()]];
    }
    [self run];
  }
}

- (void)notifyReceivedWithJavaNioByteBuffer:(JavaNioByteBuffer *)encrypted {
  @synchronized(self) {
    jint original = [((JavaNioByteBuffer *) nil_chk(encrypted)) remaining];
    @try {
      EduUmassCsUtilsUtil_putWithJavaNioByteBuffer_withJavaNioByteBuffer_(unwrapSrc_, encrypted);
    }
    @catch (JavaNioBufferOverflowException *boe) {
      JreStrongAssign(&unwrapSrc_, EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withJavaNioByteBuffer_(self, unwrapSrc_, encrypted));
      [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, INFO) withNSString:@"{0} increased unwrapSrc buffer size to {1}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self, JavaLangInteger_valueOfWithInt_([((JavaNioByteBuffer *) nil_chk(unwrapSrc_)) capacity]) } count:2 type:NSObject_class_()]];
    }
    EduUmassCsNioNioutilsNIOInstrumenter_incrEncrBytesRcvdWithInt_(original - [encrypted remaining]);
    [self run];
  }
}

- (JavaNioByteBuffer *)getBiggerBufferWithJavaNioByteBuffer:(JavaNioByteBuffer *)buf1
                                      withJavaNioByteBuffer:(JavaNioByteBuffer *)buf2 {
  return EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withJavaNioByteBuffer_(self, buf1, buf2);
}

+ (JavaNioByteBuffer *)getBiggerBufferWithJavaNioByteBuffer:(JavaNioByteBuffer *)buf
                                                    withInt:(jint)size {
  return EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withInt_(buf, size);
}

- (void)run {
  @synchronized(self) {
    while (EduUmassCsNioAbstractNIOSSL_step(self)) continue;
  }
}

- (jboolean)step {
  return EduUmassCsNioAbstractNIOSSL_step(self);
}

- (jboolean)wrap {
  return EduUmassCsNioAbstractNIOSSL_wrap(self);
}

- (void)drainOutbound {
  EduUmassCsNioAbstractNIOSSL_drainOutbound(self);
}

- (void)pushOutbound {
  EduUmassCsNioAbstractNIOSSL_pushOutbound(self);
}

- (void)pullInbound {
  EduUmassCsNioAbstractNIOSSL_pullInbound(self);
}

- (jboolean)unwrap {
  return EduUmassCsNioAbstractNIOSSL_unwrap(self);
}

- (NSString *)description {
  return JreStrcat("$C$C@", [EduUmassCsNioAbstractNIOSSL_class_() getSimpleName], ':', self->myID_, ':', (self->key_ != nil ? [self->key_ channel] : (id) @""));
}

- (void)poke {
  [self run];
}

- (void)clean {
  EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(self->unwrapDst_);
  EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(self->unwrapSrc_);
  EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(self->wrapDst_);
  EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(self->wrapSrc_);
}

+ (void)cleanWithJavaNioByteBuffer:(JavaNioByteBuffer *)bbuf {
  EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(bbuf);
}

- (void)dealloc {
  RELEASE_(wrapSrc_);
  RELEASE_(unwrapSrc_);
  RELEASE_(wrapDst_);
  RELEASE_(unwrapDst_);
  RELEASE_(engine_);
  RELEASE_(taskWorkers_);
  RELEASE_(myID_);
  RELEASE_(key_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x401, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x401, 3, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x401, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x401, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x401, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x21, 6, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x21, 7, 2, -1, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x2, 8, 9, -1, -1, 10, -1 },
    { NULL, "LJavaNioByteBuffer;", 0xa, 8, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x21, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x22, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x22, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 12, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 13, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaNioChannelsSelectionKey:withJavaxNetSslSSLEngine:withJavaUtilConcurrentExecutor:withNSString:);
  methods[1].selector = @selector(onInboundDataWithJavaNioByteBuffer:);
  methods[2].selector = @selector(onOutboundDataWithJavaNioByteBuffer:);
  methods[3].selector = @selector(onHandshakeFailureWithJavaLangException:);
  methods[4].selector = @selector(onHandshakeSuccess);
  methods[5].selector = @selector(onClosed);
  methods[6].selector = @selector(nioSendWithJavaNioByteBuffer:);
  methods[7].selector = @selector(notifyReceivedWithJavaNioByteBuffer:);
  methods[8].selector = @selector(getBiggerBufferWithJavaNioByteBuffer:withJavaNioByteBuffer:);
  methods[9].selector = @selector(getBiggerBufferWithJavaNioByteBuffer:withInt:);
  methods[10].selector = @selector(run);
  methods[11].selector = @selector(step);
  methods[12].selector = @selector(wrap);
  methods[13].selector = @selector(drainOutbound);
  methods[14].selector = @selector(pushOutbound);
  methods[15].selector = @selector(pullInbound);
  methods[16].selector = @selector(unwrap);
  methods[17].selector = @selector(description);
  methods[18].selector = @selector(poke);
  methods[19].selector = @selector(clean);
  methods[20].selector = @selector(cleanWithJavaNioByteBuffer:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT_BUFFER_SIZE", "I", .constantValue.asInt = EduUmassCsNioAbstractNIOSSL_DEFAULT_BUFFER_SIZE, 0x1a, -1, -1, -1, -1 },
    { "MAX_FACTOR", "I", .constantValue.asInt = EduUmassCsNioAbstractNIOSSL_MAX_FACTOR, 0x1a, -1, -1, -1, -1 },
    { "MAX_BUFFER_SIZE", "I", .constantValue.asInt = EduUmassCsNioAbstractNIOSSL_MAX_BUFFER_SIZE, 0x1a, -1, -1, -1, -1 },
    { "MAX_DST_BUFFER_SIZE", "I", .constantValue.asInt = EduUmassCsNioAbstractNIOSSL_MAX_DST_BUFFER_SIZE, 0x1a, -1, -1, -1, -1 },
    { "wrapSrc_", "LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "unwrapSrc_", "LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "wrapDst_", "LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "unwrapDst_", "LJavaNioByteBuffer;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "engine_", "LJavaxNetSslSSLEngine;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "taskWorkers_", "LJavaUtilConcurrentExecutor;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "myID_", "LNSString;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "key_", "LJavaNioChannelsSelectionKey;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "log", "LJavaUtilLoggingLogger;", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaNioChannelsSelectionKey;LJavaxNetSslSSLEngine;LJavaUtilConcurrentExecutor;LNSString;", "onInboundData", "LJavaNioByteBuffer;", "onOutboundData", "onHandshakeFailure", "LJavaLangException;", "nioSend", "notifyReceived", "getBiggerBuffer", "LJavaNioByteBuffer;LJavaNioByteBuffer;", (void *)&EduUmassCsNioAbstractNIOSSL__Annotations$0, "LJavaNioByteBuffer;I", "toString", "clean", &EduUmassCsNioAbstractNIOSSL_log };
  static const J2ObjcClassInfo _EduUmassCsNioAbstractNIOSSL = { "AbstractNIOSSL", "edu.umass.cs.nio", ptrTable, methods, fields, 7, 0x401, 21, 13, -1, -1, -1, -1, -1 };
  return &_EduUmassCsNioAbstractNIOSSL;
}

+ (void)initialize {
  if (self == [EduUmassCsNioAbstractNIOSSL class]) {
    JreStrongAssign(&EduUmassCsNioAbstractNIOSSL_log, JavaUtilLoggingLogger_getLoggerWithNSString_([EduUmassCsNioNIOTransport_class_() getName]));
    J2OBJC_SET_INITIALIZED(EduUmassCsNioAbstractNIOSSL)
  }
}

@end

void EduUmassCsNioAbstractNIOSSL_initWithJavaNioChannelsSelectionKey_withJavaxNetSslSSLEngine_withJavaUtilConcurrentExecutor_withNSString_(EduUmassCsNioAbstractNIOSSL *self, JavaNioChannelsSelectionKey *key, JavaxNetSslSSLEngine *engine, id<JavaUtilConcurrentExecutor> taskWorkers, NSString *myID) {
  NSObject_init(self);
  JreStrongAssign(&self->wrapSrc_, JavaNioByteBuffer_allocateDirectWithInt_(EduUmassCsNioAbstractNIOSSL_DEFAULT_BUFFER_SIZE));
  JreStrongAssign(&self->wrapDst_, JavaNioByteBuffer_allocateDirectWithInt_(EduUmassCsNioAbstractNIOSSL_DEFAULT_BUFFER_SIZE));
  JreStrongAssign(&self->unwrapSrc_, JavaNioByteBuffer_allocateDirectWithInt_(EduUmassCsNioAbstractNIOSSL_DEFAULT_BUFFER_SIZE));
  JreStrongAssign(&self->unwrapDst_, JavaNioByteBuffer_allocateDirectWithInt_(EduUmassCsNioAbstractNIOSSL_DEFAULT_BUFFER_SIZE));
  JreStrongAssign(&self->engine_, engine);
  JreStrongAssign(&self->taskWorkers_, taskWorkers);
  JreStrongAssign(&self->key_, key);
  JreStrongAssign(&self->myID_, myID);
  [self run];
}

JavaNioByteBuffer *EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withJavaNioByteBuffer_(EduUmassCsNioAbstractNIOSSL *self, JavaNioByteBuffer *buf1, JavaNioByteBuffer *buf2) {
  jint biggerSize = [((JavaNioByteBuffer *) nil_chk(buf1)) position] + [((JavaNioByteBuffer *) nil_chk(buf2)) remaining];
  if (biggerSize > EduUmassCsNioAbstractNIOSSL_MAX_BUFFER_SIZE) {
    [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, WARNING) withNSString:@"{0} reached maximum allowed buffer size limit" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self } count:1 type:NSObject_class_()]];
    @throw create_JavaNioBufferOverflowException_init();
  }
  JavaNioByteBuffer *biggerBuf = JavaNioByteBuffer_allocateWithInt_(biggerSize);
  [buf1 flip];
  [((JavaNioByteBuffer *) nil_chk(biggerBuf)) putWithJavaNioByteBuffer:buf1];
  [biggerBuf putWithJavaNioByteBuffer:buf2];
  [buf1 compact];
  return biggerBuf;
}

JavaNioByteBuffer *EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withInt_(JavaNioByteBuffer *buf, jint size) {
  EduUmassCsNioAbstractNIOSSL_initialize();
  JavaNioByteBuffer *b = JavaNioByteBuffer_allocateWithInt_(size);
  [((JavaNioByteBuffer *) nil_chk(buf)) flip];
  [((JavaNioByteBuffer *) nil_chk(b)) putWithJavaNioByteBuffer:buf];
  return b;
}

jboolean EduUmassCsNioAbstractNIOSSL_step(EduUmassCsNioAbstractNIOSSL *self) {
  {
    jboolean anything;
    id<JavaLangRunnable> sslTask;
    id<JavaLangRunnable> wrappedTask;
    switch ([[((JavaxNetSslSSLEngine *) nil_chk(self->engine_)) getHandshakeStatus] ordinal]) {
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NOT_HANDSHAKING:
      anything = false;
      {
        if ([((JavaNioByteBuffer *) nil_chk(self->wrapSrc_)) position] > 0) anything |= EduUmassCsNioAbstractNIOSSL_wrap(self);
        if ([((JavaNioByteBuffer *) nil_chk(self->unwrapSrc_)) position] > 0) anything |= EduUmassCsNioAbstractNIOSSL_unwrap(self);
      }
      return anything;
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NEED_WRAP:
      if (!EduUmassCsNioAbstractNIOSSL_wrap(self)) return false;
      break;
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NEED_UNWRAP:
      if (!EduUmassCsNioAbstractNIOSSL_unwrap(self)) return false;
      break;
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_NEED_TASK:
      sslTask = [self->engine_ getDelegatedTask];
      if (sslTask == nil) return false;
      wrappedTask = create_EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(self, sslTask);
      [((id<JavaUtilConcurrentExecutor>) nil_chk(self->taskWorkers_)) executeWithJavaLangRunnable:wrappedTask];
      return false;
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_FINISHED:
      @throw create_JavaLangIllegalStateException_initWithNSString_(@"FINISHED");
    }
  }
  return true;
}

jboolean EduUmassCsNioAbstractNIOSSL_wrap(EduUmassCsNioAbstractNIOSSL *self) {
  @synchronized(self) {
    JavaxNetSslSSLEngineResult *wrapResult;
    @try {
      [((JavaNioByteBuffer *) nil_chk(self->wrapSrc_)) flip];
      wrapResult = [((JavaxNetSslSSLEngine *) nil_chk(self->engine_)) wrapWithJavaNioByteBuffer:self->wrapSrc_ withJavaNioByteBuffer:self->wrapDst_];
      [((JavaNioByteBuffer *) nil_chk(self->wrapSrc_)) compact];
    }
    @catch (JavaxNetSslSSLException *exc) {
      [self onHandshakeFailureWithJavaLangException:exc];
      return false;
    }
    {
      jint biggerSize;
      switch ([[((JavaxNetSslSSLEngineResult *) nil_chk(wrapResult)) getStatus] ordinal]) {
        case JavaxNetSslSSLEngineResult_Status_Enum_OK:
        if ([((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) position] > 0) EduUmassCsNioAbstractNIOSSL_drainOutbound(self);
        break;
        case JavaxNetSslSSLEngineResult_Status_Enum_BUFFER_UNDERFLOW:
        [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, FINEST) withNSString:@"{0} wrap BUFFER_UNDERFLOW" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self } count:1 type:NSObject_class_()]];
        break;
        case JavaxNetSslSSLEngineResult_Status_Enum_BUFFER_OVERFLOW:
        [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, INFO) withNSString:@"{0} wrap BUFFER_OVERFLOW: Wrapped data is coming faster than the network can send it out." withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self } count:1 type:NSObject_class_()]];
        biggerSize = [((id<JavaxNetSslSSLSession>) nil_chk([((JavaxNetSslSSLEngine *) nil_chk(self->engine_)) getSession])) getApplicationBufferSize] + [((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) capacity];
        if (biggerSize < EduUmassCsNioAbstractNIOSSL_MAX_DST_BUFFER_SIZE) {
          JreStrongAssign(&self->wrapDst_, EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withInt_(self->wrapDst_, biggerSize));
          [EduUmassCsNioAbstractNIOSSL_log logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, INFO) withNSString:@"{0} increased wrapDst buffer size to {1}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self, JavaLangInteger_valueOfWithInt_([((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) capacity]) } count:2 type:NSObject_class_()]];
        }
        EduUmassCsNioAbstractNIOSSL_drainOutbound(self);
        break;
        case JavaxNetSslSSLEngineResult_Status_Enum_CLOSED:
        [self onClosed];
        return false;
      }
    }
    switch ([[wrapResult getHandshakeStatus] ordinal]) {
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_FINISHED:
      [self onHandshakeSuccess];
      return false;
      default:
      break;
    }
    return true;
  }
}

void EduUmassCsNioAbstractNIOSSL_drainOutbound(EduUmassCsNioAbstractNIOSSL *self) {
  if ([((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) position] > 0) {
    EduUmassCsNioAbstractNIOSSL_pushOutbound(self);
    if ([((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) position] == 0) return;
    id<JavaLangRunnable> pushTask = create_EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(self);
    [((id<JavaUtilConcurrentExecutor>) nil_chk(self->taskWorkers_)) executeWithJavaLangRunnable:pushTask];
  }
}

void EduUmassCsNioAbstractNIOSSL_pushOutbound(EduUmassCsNioAbstractNIOSSL *self) {
  [((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) flip];
  [self onOutboundDataWithJavaNioByteBuffer:self->wrapDst_];
  [((JavaNioByteBuffer *) nil_chk(self->wrapDst_)) compact];
}

void EduUmassCsNioAbstractNIOSSL_pullInbound(EduUmassCsNioAbstractNIOSSL *self) {
  [((JavaNioByteBuffer *) nil_chk(self->unwrapDst_)) flip];
  [self onInboundDataWithJavaNioByteBuffer:self->unwrapDst_];
  [((JavaNioByteBuffer *) nil_chk(self->unwrapDst_)) compact];
}

jboolean EduUmassCsNioAbstractNIOSSL_unwrap(EduUmassCsNioAbstractNIOSSL *self) {
  @synchronized(self) {
    JavaxNetSslSSLEngineResult *unwrapResult;
    @try {
      [((JavaNioByteBuffer *) nil_chk(self->unwrapSrc_)) flip];
      unwrapResult = [((JavaxNetSslSSLEngine *) nil_chk(self->engine_)) unwrapWithJavaNioByteBuffer:self->unwrapSrc_ withJavaNioByteBuffer:self->unwrapDst_];
      [((JavaNioByteBuffer *) nil_chk(self->unwrapSrc_)) compact];
    }
    @catch (JavaxNetSslSSLException *exc) {
      [self onHandshakeFailureWithJavaLangException:exc];
      return false;
    }
    {
      jint biggerSize;
      switch ([[((JavaxNetSslSSLEngineResult *) nil_chk(unwrapResult)) getStatus] ordinal]) {
        case JavaxNetSslSSLEngineResult_Status_Enum_OK:
        if ([((JavaNioByteBuffer *) nil_chk(self->unwrapDst_)) position] > 0) EduUmassCsNioAbstractNIOSSL_pullInbound(self);
        break;
        case JavaxNetSslSSLEngineResult_Status_Enum_CLOSED:
        [self onClosed];
        return false;
        case JavaxNetSslSSLEngineResult_Status_Enum_BUFFER_OVERFLOW:
        [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, INFO) withNSString:@"{0} unwrap BUFFER_OVERFLOW: Network data is coming in faster than can be unwrapped" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self } count:1 type:NSObject_class_()]];
        biggerSize = [((id<JavaxNetSslSSLSession>) nil_chk([((JavaxNetSslSSLEngine *) nil_chk(self->engine_)) getSession])) getApplicationBufferSize] + [((JavaNioByteBuffer *) nil_chk(self->unwrapDst_)) capacity];
        if (biggerSize < EduUmassCsNioAbstractNIOSSL_MAX_BUFFER_SIZE) {
          JreStrongAssign(&self->unwrapDst_, EduUmassCsNioAbstractNIOSSL_getBiggerBufferWithJavaNioByteBuffer_withInt_(self->unwrapDst_, biggerSize));
          [EduUmassCsNioAbstractNIOSSL_log logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, INFO) withNSString:@"{0} increased unwrapDst buffer size to {1}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self, JavaLangInteger_valueOfWithInt_([((JavaNioByteBuffer *) nil_chk(self->unwrapDst_)) capacity]) } count:2 type:NSObject_class_()]];
        }
        EduUmassCsNioAbstractNIOSSL_pullInbound(self);
        break;
        case JavaxNetSslSSLEngineResult_Status_Enum_BUFFER_UNDERFLOW:
        [((JavaUtilLoggingLogger *) nil_chk(EduUmassCsNioAbstractNIOSSL_log)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, FINEST) withNSString:@"{0} unwrap BUFFER_UNDERFLOW" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self } count:1 type:NSObject_class_()]];
        return false;
      }
    }
    switch ([[unwrapResult getHandshakeStatus] ordinal]) {
      case JavaxNetSslSSLEngineResult_HandshakeStatus_Enum_FINISHED:
      [self onHandshakeSuccess];
      return false;
      default:
      break;
    }
    return true;
  }
}

void EduUmassCsNioAbstractNIOSSL_cleanWithJavaNioByteBuffer_(JavaNioByteBuffer *bbuf) {
  EduUmassCsNioAbstractNIOSSL_initialize();
  SunMiscCleaner *cleaner = nil;
  if (cleaner == nil) @try {
    JavaLangReflectField *cleanerField = [[((JavaNioByteBuffer *) nil_chk(bbuf)) java_getClass] getDeclaredField:@"cleaner"];
    [((JavaLangReflectField *) nil_chk(cleanerField)) setAccessibleWithBoolean:true];
    cleaner = (SunMiscCleaner *) cast_chk([cleanerField getWithId:bbuf], [SunMiscCleaner class]);
  }
  @catch (JavaLangNoSuchFieldException *e) {
    [((JavaLangException *) nil_chk(e)) printStackTrace];
  }
  @catch (JavaLangSecurityException *e) {
    [((JavaLangException *) nil_chk(e)) printStackTrace];
  }
  @catch (JavaLangIllegalArgumentException *e) {
    [((JavaLangException *) nil_chk(e)) printStackTrace];
  }
  @catch (JavaLangIllegalAccessException *e) {
    [((JavaLangException *) nil_chk(e)) printStackTrace];
  }
  if (cleaner != nil) [cleaner clean];
}

IOSObjectArray *EduUmassCsNioAbstractNIOSSL__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUmassCsNioAbstractNIOSSL)

@implementation EduUmassCsNioAbstractNIOSSL_1

- (instancetype)initWithEduUmassCsNioAbstractNIOSSL:(EduUmassCsNioAbstractNIOSSL *)outer$
                               withJavaLangRunnable:(id<JavaLangRunnable>)capture$0 {
  EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(self, outer$, capture$0);
  return self;
}

- (void)run {
  @try {
    jlong t0 = JavaLangSystem_nanoTime();
    [((id<JavaLangRunnable>) nil_chk(val$sslTask_)) run];
    [((JavaUtilLoggingLogger *) nil_chk(JreLoadStatic(EduUmassCsNioAbstractNIOSSL, log))) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, FINEST) withNSString:@"{0} async SSL task {1} took {2}ms" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ self, val$sslTask_, JavaLangLong_valueOfWithLong_((JavaLangSystem_nanoTime() - t0) / 1000000) } count:3 type:NSObject_class_()]];
    [this$0_ run];
  }
  @catch (JavaLangException *e) {
    [((JavaLangException *) nil_chk(e)) printStackTrace];
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$sslTask_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduUmassCsNioAbstractNIOSSL:withJavaLangRunnable:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LEduUmassCsNioAbstractNIOSSL;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$sslTask_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduUmassCsNioAbstractNIOSSL;", "step" };
  static const J2ObjcClassInfo _EduUmassCsNioAbstractNIOSSL_1 = { "", "edu.umass.cs.nio", ptrTable, methods, fields, 7, 0x8008, 2, 2, 0, -1, 1, -1, -1 };
  return &_EduUmassCsNioAbstractNIOSSL_1;
}

@end

void EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(EduUmassCsNioAbstractNIOSSL_1 *self, EduUmassCsNioAbstractNIOSSL *outer$, id<JavaLangRunnable> capture$0) {
  JreStrongAssign(&self->this$0_, outer$);
  JreStrongAssign(&self->val$sslTask_, capture$0);
  NSObject_init(self);
}

EduUmassCsNioAbstractNIOSSL_1 *new_EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(EduUmassCsNioAbstractNIOSSL *outer$, id<JavaLangRunnable> capture$0) {
  J2OBJC_NEW_IMPL(EduUmassCsNioAbstractNIOSSL_1, initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_, outer$, capture$0)
}

EduUmassCsNioAbstractNIOSSL_1 *create_EduUmassCsNioAbstractNIOSSL_1_initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_(EduUmassCsNioAbstractNIOSSL *outer$, id<JavaLangRunnable> capture$0) {
  J2OBJC_CREATE_IMPL(EduUmassCsNioAbstractNIOSSL_1, initWithEduUmassCsNioAbstractNIOSSL_withJavaLangRunnable_, outer$, capture$0)
}

@implementation EduUmassCsNioAbstractNIOSSL_2

- (instancetype)initWithEduUmassCsNioAbstractNIOSSL:(EduUmassCsNioAbstractNIOSSL *)outer$ {
  EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(self, outer$);
  return self;
}

- (void)run {
  while ([((JavaNioByteBuffer *) nil_chk(this$0_->wrapDst_)) position] > 0) {
    jint prev = [((JavaNioByteBuffer *) nil_chk(this$0_->wrapDst_)) position];
    @synchronized(this$0_) {
      [((JavaNioByteBuffer *) nil_chk(this$0_->wrapDst_)) flip];
      [this$0_ onOutboundDataWithJavaNioByteBuffer:this$0_->wrapDst_];
      [((JavaNioByteBuffer *) nil_chk(this$0_->wrapDst_)) compact];
    }
    if ([((JavaNioByteBuffer *) nil_chk(this$0_->wrapDst_)) position] == prev) JavaLangThread_yield();
  }
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduUmassCsNioAbstractNIOSSL:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LEduUmassCsNioAbstractNIOSSL;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduUmassCsNioAbstractNIOSSL;", "drainOutbound" };
  static const J2ObjcClassInfo _EduUmassCsNioAbstractNIOSSL_2 = { "", "edu.umass.cs.nio", ptrTable, methods, fields, 7, 0x8008, 2, 1, 0, -1, 1, -1, -1 };
  return &_EduUmassCsNioAbstractNIOSSL_2;
}

@end

void EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(EduUmassCsNioAbstractNIOSSL_2 *self, EduUmassCsNioAbstractNIOSSL *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
}

EduUmassCsNioAbstractNIOSSL_2 *new_EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(EduUmassCsNioAbstractNIOSSL *outer$) {
  J2OBJC_NEW_IMPL(EduUmassCsNioAbstractNIOSSL_2, initWithEduUmassCsNioAbstractNIOSSL_, outer$)
}

EduUmassCsNioAbstractNIOSSL_2 *create_EduUmassCsNioAbstractNIOSSL_2_initWithEduUmassCsNioAbstractNIOSSL_(EduUmassCsNioAbstractNIOSSL *outer$) {
  J2OBJC_CREATE_IMPL(EduUmassCsNioAbstractNIOSSL_2, initWithEduUmassCsNioAbstractNIOSSL_, outer$)
}
