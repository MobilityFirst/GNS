//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../../gig_ios/src/edu/umass/cs/utils/GCConcurrentHashMap.java
//

#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "edu/umass/cs/utils/GCConcurrentHashMap.h"
#include "edu/umass/cs/utils/GCConcurrentHashMapCallback.h"
#include "edu/umass/cs/utils/Util.h"
#include "java/lang/Long.h"
#include "java/lang/System.h"
#include "java/util/Iterator.h"
#include "java/util/LinkedHashMap.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentHashMap.h"

@interface EduUmassCsUtilsGCConcurrentHashMap () {
 @public
  jint gcThresholdSize_;
  JavaUtilLinkedHashMap *putTimes_;
  id<EduUmassCsUtilsGCConcurrentHashMapCallback> callback_;
  jlong gcTimeout_;
  jint numGC_;
  jint numGCAttempts_;
  jlong lastGCTime_;
  jlong minGCInterval_;
}

- (void)putGCWithId:(id)key;

- (void)GC;

- (void)GCWithLong:(jlong)timeout;

@end

J2OBJC_FIELD_SETTER(EduUmassCsUtilsGCConcurrentHashMap, putTimes_, JavaUtilLinkedHashMap *)
J2OBJC_FIELD_SETTER(EduUmassCsUtilsGCConcurrentHashMap, callback_, id<EduUmassCsUtilsGCConcurrentHashMapCallback>)

inline jint EduUmassCsUtilsGCConcurrentHashMap_get_DEFAULT_GC_TIMEOUT();
#define EduUmassCsUtilsGCConcurrentHashMap_DEFAULT_GC_TIMEOUT 10000
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsUtilsGCConcurrentHashMap, DEFAULT_GC_TIMEOUT, jint)

inline jint EduUmassCsUtilsGCConcurrentHashMap_get_DEFAULT_GC_THRESHOLD_SIZE();
#define EduUmassCsUtilsGCConcurrentHashMap_DEFAULT_GC_THRESHOLD_SIZE 65536
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsUtilsGCConcurrentHashMap, DEFAULT_GC_THRESHOLD_SIZE, jint)

inline jlong EduUmassCsUtilsGCConcurrentHashMap_get_serialVersionUID();
#define EduUmassCsUtilsGCConcurrentHashMap_serialVersionUID 183021919212LL
J2OBJC_STATIC_FIELD_CONSTANT(EduUmassCsUtilsGCConcurrentHashMap, serialVersionUID, jlong)

__attribute__((unused)) static void EduUmassCsUtilsGCConcurrentHashMap_putGCWithId_(EduUmassCsUtilsGCConcurrentHashMap *self, id key);

__attribute__((unused)) static void EduUmassCsUtilsGCConcurrentHashMap_GC(EduUmassCsUtilsGCConcurrentHashMap *self);

__attribute__((unused)) static void EduUmassCsUtilsGCConcurrentHashMap_GCWithLong_(EduUmassCsUtilsGCConcurrentHashMap *self, jlong timeout);

@implementation EduUmassCsUtilsGCConcurrentHashMap

- (instancetype)initWithEduUmassCsUtilsGCConcurrentHashMapCallback:(id<EduUmassCsUtilsGCConcurrentHashMapCallback>)callback
                                                          withLong:(jlong)gcTimeout {
  EduUmassCsUtilsGCConcurrentHashMap_initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_(self, callback, gcTimeout);
  return self;
}

- (instancetype)initWithLong:(jlong)gcTimeout {
  EduUmassCsUtilsGCConcurrentHashMap_initWithLong_(self, gcTimeout);
  return self;
}

- (id)putWithId:(id)key
         withId:(id)value {
  @synchronized(self) {
    EduUmassCsUtilsGCConcurrentHashMap_putGCWithId_(self, key);
    id old = [super putWithId:key withId:value];
    return old;
  }
}

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value {
  @synchronized(self) {
    EduUmassCsUtilsGCConcurrentHashMap_putGCWithId_(self, key);
    return [super putIfAbsentWithId:key withId:value];
  }
}

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map {
  @synchronized(self) {
    for (id __strong key in nil_chk([((id<JavaUtilMap>) nil_chk(map)) keySet])) EduUmassCsUtilsGCConcurrentHashMap_putGCWithId_(self, key);
    [super putAllWithJavaUtilMap:map];
  }
}

- (id)removeWithId:(id)key {
  @synchronized(self) {
    id value = [super removeWithId:key];
    [((JavaUtilLinkedHashMap *) nil_chk(self->putTimes_)) removeWithId:key];
    return value;
  }
}

- (EduUmassCsUtilsGCConcurrentHashMap *)setGCThresholdSizeWithInt:(jint)size {
  self->gcThresholdSize_ = size;
  return self;
}

- (EduUmassCsUtilsGCConcurrentHashMap *)setGCTimeoutWithLong:(jlong)timeout {
  self->gcTimeout_ = timeout;
  return self;
}

- (jboolean)removeWithId:(id)key
                  withId:(id)value {
  @synchronized(self) {
    if ([super removeWithId:key withId:value]) {
      [((JavaUtilLinkedHashMap *) nil_chk(self->putTimes_)) removeWithId:key];
      return true;
    }
    return false;
  }
}

- (void)putGCWithId:(id)key {
  EduUmassCsUtilsGCConcurrentHashMap_putGCWithId_(self, key);
}

- (void)tryGCWithLong:(jlong)timeout {
  @synchronized(self) {
    EduUmassCsUtilsGCConcurrentHashMap_GCWithLong_(self, timeout);
  }
}

- (void)GC {
  EduUmassCsUtilsGCConcurrentHashMap_GC(self);
}

- (void)GCWithLong:(jlong)timeout {
  EduUmassCsUtilsGCConcurrentHashMap_GCWithLong_(self, timeout);
}

+ (void)mainWithNSStringArray:(IOSObjectArray *)args {
  EduUmassCsUtilsGCConcurrentHashMap_mainWithNSStringArray_(args);
}

- (void)dealloc {
  RELEASE_(putTimes_);
  RELEASE_(callback_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x21, 2, 3, -1, 4, -1, -1 },
    { NULL, "LNSObject;", 0x21, 5, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x21, 6, 7, -1, 8, -1, -1 },
    { NULL, "LNSObject;", 0x21, 9, 10, -1, 11, -1, -1 },
    { NULL, "LEduUmassCsUtilsGCConcurrentHashMap;", 0x1, 12, 13, -1, 14, -1, -1 },
    { NULL, "LEduUmassCsUtilsGCConcurrentHashMap;", 0x1, 15, 1, -1, 16, -1, -1 },
    { NULL, "Z", 0x21, 9, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x22, 17, 10, -1, 18, -1, -1 },
    { NULL, "V", 0x21, 19, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x22, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x22, 20, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 21, 22, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithEduUmassCsUtilsGCConcurrentHashMapCallback:withLong:);
  methods[1].selector = @selector(initWithLong:);
  methods[2].selector = @selector(putWithId:withId:);
  methods[3].selector = @selector(putIfAbsentWithId:withId:);
  methods[4].selector = @selector(putAllWithJavaUtilMap:);
  methods[5].selector = @selector(removeWithId:);
  methods[6].selector = @selector(setGCThresholdSizeWithInt:);
  methods[7].selector = @selector(setGCTimeoutWithLong:);
  methods[8].selector = @selector(removeWithId:withId:);
  methods[9].selector = @selector(putGCWithId:);
  methods[10].selector = @selector(tryGCWithLong:);
  methods[11].selector = @selector(GC);
  methods[12].selector = @selector(GCWithLong:);
  methods[13].selector = @selector(mainWithNSStringArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT_GC_TIMEOUT", "I", .constantValue.asInt = EduUmassCsUtilsGCConcurrentHashMap_DEFAULT_GC_TIMEOUT, 0x1a, -1, -1, -1, -1 },
    { "DEFAULT_GC_THRESHOLD_SIZE", "I", .constantValue.asInt = EduUmassCsUtilsGCConcurrentHashMap_DEFAULT_GC_THRESHOLD_SIZE, 0x1a, -1, -1, -1, -1 },
    { "gcThresholdSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "putTimes_", "LJavaUtilLinkedHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 23, -1 },
    { "callback_", "LEduUmassCsUtilsGCConcurrentHashMapCallback;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "gcTimeout_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "serialVersionUID", "J", .constantValue.asLong = EduUmassCsUtilsGCConcurrentHashMap_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "numGC_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "numGCAttempts_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lastGCTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "minGCInterval_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEduUmassCsUtilsGCConcurrentHashMapCallback;J", "J", "put", "LNSObject;LNSObject;", "(TK;TV;)TV;", "putIfAbsent", "putAll", "LJavaUtilMap;", "(Ljava/util/Map<+TK;+TV;>;)V", "remove", "LNSObject;", "(Ljava/lang/Object;)TV;", "setGCThresholdSize", "I", "(I)Ledu/umass/cs/utils/GCConcurrentHashMap<TK;TV;>;", "setGCTimeout", "(J)Ledu/umass/cs/utils/GCConcurrentHashMap<TK;TV;>;", "putGC", "(TK;)V", "tryGC", "GC", "main", "[LNSString;", "Ljava/util/LinkedHashMap<TK;Ljava/lang/Long;>;", "<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/concurrent/ConcurrentHashMap<TK;TV;>;" };
  static const J2ObjcClassInfo _EduUmassCsUtilsGCConcurrentHashMap = { "GCConcurrentHashMap", "edu.umass.cs.utils", ptrTable, methods, fields, 7, 0x1, 14, 11, -1, -1, -1, 24, -1 };
  return &_EduUmassCsUtilsGCConcurrentHashMap;
}

@end

void EduUmassCsUtilsGCConcurrentHashMap_initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_(EduUmassCsUtilsGCConcurrentHashMap *self, id<EduUmassCsUtilsGCConcurrentHashMapCallback> callback, jlong gcTimeout) {
  JavaUtilConcurrentConcurrentHashMap_init(self);
  self->gcThresholdSize_ = EduUmassCsUtilsGCConcurrentHashMap_DEFAULT_GC_THRESHOLD_SIZE;
  JreStrongAssignAndConsume(&self->putTimes_, new_JavaUtilLinkedHashMap_init());
  self->numGC_ = 0;
  self->numGCAttempts_ = 0;
  self->lastGCTime_ = 0;
  self->minGCInterval_ = EduUmassCsUtilsGCConcurrentHashMap_DEFAULT_GC_TIMEOUT;
  JreStrongAssign(&self->callback_, callback);
  self->gcTimeout_ = gcTimeout;
  self->minGCInterval_ = self->gcTimeout_;
}

EduUmassCsUtilsGCConcurrentHashMap *new_EduUmassCsUtilsGCConcurrentHashMap_initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_(id<EduUmassCsUtilsGCConcurrentHashMapCallback> callback, jlong gcTimeout) {
  J2OBJC_NEW_IMPL(EduUmassCsUtilsGCConcurrentHashMap, initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_, callback, gcTimeout)
}

EduUmassCsUtilsGCConcurrentHashMap *create_EduUmassCsUtilsGCConcurrentHashMap_initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_(id<EduUmassCsUtilsGCConcurrentHashMapCallback> callback, jlong gcTimeout) {
  J2OBJC_CREATE_IMPL(EduUmassCsUtilsGCConcurrentHashMap, initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_, callback, gcTimeout)
}

void EduUmassCsUtilsGCConcurrentHashMap_initWithLong_(EduUmassCsUtilsGCConcurrentHashMap *self, jlong gcTimeout) {
  EduUmassCsUtilsGCConcurrentHashMap_initWithEduUmassCsUtilsGCConcurrentHashMapCallback_withLong_(self, nil, gcTimeout);
}

EduUmassCsUtilsGCConcurrentHashMap *new_EduUmassCsUtilsGCConcurrentHashMap_initWithLong_(jlong gcTimeout) {
  J2OBJC_NEW_IMPL(EduUmassCsUtilsGCConcurrentHashMap, initWithLong_, gcTimeout)
}

EduUmassCsUtilsGCConcurrentHashMap *create_EduUmassCsUtilsGCConcurrentHashMap_initWithLong_(jlong gcTimeout) {
  J2OBJC_CREATE_IMPL(EduUmassCsUtilsGCConcurrentHashMap, initWithLong_, gcTimeout)
}

void EduUmassCsUtilsGCConcurrentHashMap_putGCWithId_(EduUmassCsUtilsGCConcurrentHashMap *self, id key) {
  @synchronized(self) {
    [((JavaUtilLinkedHashMap *) nil_chk(self->putTimes_)) putWithId:key withId:JavaLangLong_valueOfWithLong_(JavaLangSystem_currentTimeMillis())];
    if ([self size] > self->gcThresholdSize_ || EduUmassCsUtilsUtil_oneInWithInt_(1000)) EduUmassCsUtilsGCConcurrentHashMap_GC(self);
  }
}

void EduUmassCsUtilsGCConcurrentHashMap_GC(EduUmassCsUtilsGCConcurrentHashMap *self) {
  @synchronized(self) {
    EduUmassCsUtilsGCConcurrentHashMap_GCWithLong_(self, self->gcTimeout_);
  }
}

void EduUmassCsUtilsGCConcurrentHashMap_GCWithLong_(EduUmassCsUtilsGCConcurrentHashMap *self, jlong timeout) {
  @synchronized(self) {
    if (JavaLangSystem_currentTimeMillis() - self->lastGCTime_ < self->minGCInterval_) return;
    else self->lastGCTime_ = JavaLangSystem_currentTimeMillis();
    jboolean removed = false;
    self->numGCAttempts_++;
    for (id<JavaUtilIterator> iterK = [((id<JavaUtilSet>) nil_chk([((JavaUtilLinkedHashMap *) nil_chk(self->putTimes_)) keySet])) iterator]; [((id<JavaUtilIterator>) nil_chk(iterK)) hasNext]; ) {
      id key = [iterK next];
      JavaLangLong *time = [self->putTimes_ getWithId:key];
      if (time != nil && (JavaLangSystem_currentTimeMillis() - [time longLongValue] > timeout)) {
        [iterK remove];
        id value = [self removeWithId:key];
        if (value != nil && self->callback_ != nil) [self->callback_ callbackGCWithId:key withId:value];
        removed = true;
      }
      else break;
    }
    if (removed) self->numGC_++;
  }
}

void EduUmassCsUtilsGCConcurrentHashMap_mainWithNSStringArray_(IOSObjectArray *args) {
  EduUmassCsUtilsGCConcurrentHashMap_initialize();
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUmassCsUtilsGCConcurrentHashMap)
